/* source: gcc-arm-none-eabi-4_7-2013q1/share/gcc-arm-none-eabi/samples/ldscripts/sections.ld */

/* Linker script to place sections and symbol values. Should be used together
 * with other linker script that defines memory regions FLASH and RAM.
 * It references following symbols, which must be defined in code:
 *   Reset_Handler : Entry of reset handler
 *
 * It defines following symbols, which code can use without definition:
 *   __exidx_start
 *   __exidx_end
 *   __etext
 *   __data_start__
 *   __preinit_array_start
 *   __preinit_array_end
 *   __init_array_start
 *   __init_array_end
 *   __fini_array_start
 *   __fini_array_end
 *   __data_end__
 *   __bss_start__
 *   __bss_end__
 *   __end__
 *   end
 *   __HeapLimit
 *   __StackLimit
 *   __StackTop
 *   __stack
 *
 * .text 
 * Stores the instructions that consist of the program itself. 
 * It is marked as executable and read-only (r-x).
 *
 * .rodata 
 * Stores constant data. One should expect string literals, and other constant values to reside there. 
 * It is marked as read-only (although usually resides in a read and executable segment).
 *
 * .data 
 * Is used to store static and global variables (non-static variables are stored on the stack). 
 * It is marked as read-write and non-executable (rw-).
 *
 * .bss 
 *  Stores non-initialized variables. It is marked as read-write and non-executable (rw-).
 *
 */

/* entry point */
ENTRY(__my_startup)

SECTIONS
{
    /****************************/
    /*      VECTOR TABLE        */
    /****************************/
    .isr_vector :
    {
        . = ALIGN(4);
        KEEP(*(.isr_vector)) /* Vector Table */
        . = ALIGN(4);
    } >FLASH

    .text : /* This section holds the `text,' or executable instructions, of a program. */
    {
        . = ALIGN(4);
        *(.text)  /* .text sections (code) */
        *(.text*) /*List all sysmbols which contains *.text.* */

        /* This section holds executable instructions that contribute to the process initialization code.
           When a program starts to run, the system arranges to execute the code in this section before
           calling the main program entry point (called main for C programs)
         */
        KEEP(*(.init))
        /* This section holds executable instructions that contribute to the process termination code.
           That is, when a program exits normally, the system arranges to execute the code in this section.
         */
        KEEP(*(.fini))

        /* This section contains a list of global constructor function pointers. */
        _ctors_begin = .;
        *crtbegin.o(.ctors)
        *crtbegin?.o(.ctors)
        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
        *(SORT(.ctors.*))
        *(.ctors)
        _ctors_end = .;

        /* This section contains a list of global destructor function pointers. */
        *crtbegin.o(.dtors)
        *crtbegin?.o(.dtors)
        *(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
        *(SORT(.dtors.*))
        *(.dtors)

        /* This section contains a list of global destructor function pointers. */
        KEEP(*(.eh_frame*))
    } > FLASH

    /* CONST data section */
    .rodata :
    {
        *(.rodata .rodata.*)
        *(.gnu.linkonce.r*)
    } > FLASH

    .eh_frame_hdr : ALIGN (4)
    {
      KEEP (*(.eh_frame_hdr))
    } > FLASH

    .eh_frame : ALIGN (4)
    {
      KEEP (*(.eh_frame))
    } > FLASH

    /* This section containing exception unwinding information */
    .ARM.extab : ALIGN (4)
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
    } > FLASH

    /* The exception handling index tables generated by the compiler are given in this
    section. Sections containing index entries for section unwinding */
    .ARM.exidx : ALIGN (4)
    {
        __exidx_start = .;
        *(.ARM.exidx* .gnu.linkonce.armexidx.*)
        __exidx_end = .;
    } > FLASH


    __etext = .;

    .data : AT (__etext)
    {
        _data_begin = .;
        *(vtable)
        *(.data*)

        . = ALIGN(4);
        /* This section holds an array of function pointers that contributes to a single
        pre-initialization array for the executable or shared object containing the section. */
        PROVIDE_HIDDEN (__preinit_array_start = .);
        KEEP(*(.preinit_array))
        PROVIDE_HIDDEN (__preinit_array_end = .);

        . = ALIGN(4);
        /* This section holds an array of function pointers that contributes to a single
        initialization array for the executable or shared object containing the section. */
        PROVIDE_HIDDEN (__init_array_start = .);
        KEEP(*(SORT(.init_array.*)))
        KEEP(*(.init_array))
        PROVIDE_HIDDEN (__init_array_end = .);

        . = ALIGN(4);
        /* finit data sections holds an array of function pointers that contributes to a single
        termination array for the executable or shared object containing the section.*/
        PROVIDE_HIDDEN (__fini_array_start = .);
        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array))
        PROVIDE_HIDDEN (__fini_array_end = .);

        /* All data end */
        _data_end = .;

    } > RAM

    /* This section holds data that contributes to the program's memory image.
       The program may treat this data as uninitialized.
       However, the system shall initialize this data with zeroes when the program begins to run.
    */
    .bss : ALIGN(4)
    {
        _bss_start_ = .;
        *(.bss*)
        *(COMMON)
        . = ALIGN(4);
        _bss_end_ = .;
    } > RAM

    .heap (COPY):
    {
        __end__ = .;
        end = __end__;
        *(.heap*)
        __HeapLimit = .;
    } > RAM

    /* .stack_dummy section doesn't contains any symbols. It is only
     * used for linker to calculate size of stack sections, and assign
     * values to stack symbols later */
    .stack_dummy (COPY):
    {
        *(.stack*)
    } > RAM

    /* Set stack top to end of RAM, and stack limit move down by
     * size of stack_dummy section */
    __StackTop = ORIGIN(RAM) + LENGTH(RAM);
    __initial_stack_pointer = ORIGIN(RAM) + LENGTH(RAM);
    __StackLimit = __StackTop - SIZEOF(.stack_dummy);
    PROVIDE(__stack = __StackTop); /* If the program references `__stack' but does not define it,
                                      the linker will use the definition in the linker script. */

    /* Check if data + heap + stack exceeds RAM limit */
    ASSERT(__StackLimit >= __HeapLimit, "region RAM overflowed with stack")

    _rom_data_begin = LOADADDR(.data); /* Return the absolute LMA of the named section .data */
}
