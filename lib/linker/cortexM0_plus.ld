/* source: gcc-arm-none-eabi-4_7-2013q1/share/gcc-arm-none-eabi/samples/ldscripts/sections.ld */

/* Linker script to place sections and symbol values. Should be used together
 * with other linker script that defines memory regions FLASH and RAM.
 * It references following symbols, which must be defined in code:
 *   Reset_Handler : Entry of reset handler
 *
 * It defines following symbols, which code can use without definition:
 *   __exidx_start
 *   __exidx_end
 *   __etext
 *   __data_start__
 *   __preinit_array_start
 *   __preinit_array_end
 *   __init_array_start
 *   __init_array_end
 *   __fini_array_start
 *   __fini_array_end
 *   __data_end__
 *   __bss_start__
 *   __bss_end__
 *   __end__
 *   end
 *   __HeapLimit
 *   __StackLimit
 *   __StackTop
 *   __stack
 */

/* entry point */
ENTRY(__my_startup)

/* extern declaration so that the value appears correctly for the LPC checksum calculation */
EXTERN(__nmi_handler)
EXTERN(__hard_fault_handler)

SECTIONS
{

        .text : /* This section holds the `text,' or executable instructions, of a program. */
        {
                KEEP(*(.isr_vector))
                *(.text*)

                /* This section holds executable instructions that contribute to the process initialization code.
                   When a program starts to run, the system arranges to execute the code in this section before calling the main program entry point (called main for C programs)
                 */
                KEEP(*(.init))
                /* This section holds executable instructions that contribute to the process termination code.
                   That is, when a program exits normally, the system arranges to execute the code in this section.
                 */
                KEEP(*(.fini))

                /* This section contains a list of global constructor function pointers. */
		_ctors_begin = .;
                *crtbegin.o(.ctors)
                *crtbegin?.o(.ctors)
                *(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
                *(SORT(.ctors.*))
                *(.ctors)
		_ctors_end = .;

                /* This section contains a list of global destructor function pointers. */
                *crtbegin.o(.dtors)
                *crtbegin?.o(.dtors)
                *(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
                *(SORT(.dtors.*))
                *(.dtors)

                *(.rodata*)

                /* This section contains a list of global destructor function pointers. */
                KEEP(*(.eh_frame*))
        } > FLASH

        .ARM.extab : /* sections containing exception unwinding information */
        {
                *(.ARM.extab* .gnu.linkonce.armextab.*)
        } > FLASH

        __exidx_start = .;
        .ARM.exidx : /* The exception handling index tables generated by the compiler are given in this section. Sections containing index entries for section unwinding */
        {
                *(.ARM.exidx* .gnu.linkonce.armexidx.*)
        } > FLASH
        __exidx_end = .;

        __etext = .;

        .data : AT (__etext)
        {
                _data_begin = .;
                *(vtable)
                *(.data*)

                . = ALIGN(4);
                /* This section holds an array of function pointers that contributes to a single pre-initialization array for the executable or shared object containing the section. */
                PROVIDE_HIDDEN (__preinit_array_start = .);
                KEEP(*(.preinit_array))
                PROVIDE_HIDDEN (__preinit_array_end = .);

                . = ALIGN(4);
                /* This section holds an array of function pointers that contributes to a single initialization array for the executable or shared object containing the section. */
                PROVIDE_HIDDEN (__init_array_start = .);
                KEEP(*(SORT(.init_array.*)))
                KEEP(*(.init_array))
                PROVIDE_HIDDEN (__init_array_end = .);

                . = ALIGN(4);
                /* finit data sections holds an array of function pointers that contributes to a single termination array for the executable or shared object containing the section.*/
                PROVIDE_HIDDEN (__fini_array_start = .);
                KEEP(*(SORT(.fini_array.*)))
                KEEP(*(.fini_array))
                PROVIDE_HIDDEN (__fini_array_end = .);

                /* All data end */
                _data_end = .;

        } > RAM

        /* This section holds data that contributes to the program's memory image.
           The program may treat this data as uninitialized.
           However, the system shall initialize this data with zeroes when the program begins to run.
        */
        .bss :
        {
                . = ALIGN(4);
                __bss_start__ = .;
                *(.bss*)
                *(COMMON)
                . = ALIGN(4);
                __bss_end__ = .;
        } > RAM

        .heap (COPY):
        {
                __end__ = .;
                end = __end__;
                *(.heap*)
                __HeapLimit = .;
        } > RAM

        /* .stack_dummy section doesn't contains any symbols. It is only
         * used for linker to calculate size of stack sections, and assign
         * values to stack symbols later */
        .stack_dummy (COPY):
        {
                *(.stack*)
        } > RAM

        /* Set stack top to end of RAM, and stack limit move down by
         * size of stack_dummy section */
        __StackTop = ORIGIN(RAM) + LENGTH(RAM);
	__initial_stack_pointer = ORIGIN(RAM) + LENGTH(RAM);
        __StackLimit = __StackTop - SIZEOF(.stack_dummy);
        PROVIDE(__stack = __StackTop);

        /* Check if data + heap + stack exceeds RAM limit */
        ASSERT(__StackLimit >= __HeapLimit, "region RAM overflowed with stack")

	_rom_data_begin = LOADADDR(.data);
}

